import { mkdir, readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import matter from 'gray-matter';
import { glob } from 'glob';

interface GeneratedCharacter {
    noteId: string;
    runtimeCharacterId: string;
    tier: string;
    faction: string | null;
    title: string;
    source: string;
}

interface GeneratedLocation {
    noteId: string;
    runtimeLocationId: string;
    title: string;
    runtimeType: string | null;
    source: string;
}

interface GeneratedVoice {
    noteId: string;
    voiceId: string;
    department: string | null;
    source: string;
}

const CANONICAL_VOICE_IDS = [
    'logic', 'perception', 'encyclopedia',
    'intuition', 'empathy', 'imagination',
    'authority', 'charisma', 'volition',
    'endurance', 'agility', 'senses',
    'stealth', 'deception', 'intrusion',
    'occultism', 'tradition', 'gambling'
] as const;

const thisFile = fileURLToPath(import.meta.url);
const scriptsDir = path.dirname(thisFile);
const repoRoot = path.resolve(scriptsDir, '../../../..');
const obsidianRoot = path.join(repoRoot, 'obsidian', 'Detectiv');
const generatedDir = path.join(repoRoot, 'packages', 'shared', 'data', 'generated');

const toPosix = (value: string): string => value.replace(/\\/g, '/');

const extractTitle = (markdown: string, fallback: string): string => {
    const match = markdown.match(/^#\s+(.+)$/m);
    return (match?.[1]?.trim() ?? fallback);
};

const stringify = (value: unknown): string => JSON.stringify(value, null, 4);

const render = (name: string, payload: unknown): string => `// Auto-generated by apps/server/src/scripts/obsidian-sync.ts\n// Source: obsidian/Detectiv\n\nexport const ${name} = ${stringify(payload)} as const;\n`;

const syncCharacters = async (): Promise<GeneratedCharacter[]> => {
    const files = await glob('30_World_Intel/Characters/char_*.md', {
        cwd: obsidianRoot,
        nodir: true,
        windowsPathsNoEscape: true
    });

    const items: GeneratedCharacter[] = [];
    for (const file of files) {
        const absolute = path.join(obsidianRoot, file);
        const raw = await readFile(absolute, 'utf8');
        const parsed = matter(raw);
        const data = parsed.data as Record<string, unknown>;

        const noteId = typeof data.id === 'string' ? data.id : path.basename(file, '.md');
        const runtimeCharacterId =
            (typeof data.runtime_character_id === 'string' && data.runtime_character_id.length > 0)
                ? data.runtime_character_id
                : path.basename(file, '.md').replace(/^char_/, '');

        const tier = typeof data.tier === 'string' ? data.tier : 'unknown';
        const faction = typeof data.faction === 'string' ? data.faction : null;
        const title = extractTitle(parsed.content, path.basename(file, '.md'));

        items.push({
            noteId,
            runtimeCharacterId,
            tier,
            faction,
            title,
            source: toPosix(path.join('obsidian/Detectiv', file))
        });
    }

    return items.sort((a, b) => a.runtimeCharacterId.localeCompare(b.runtimeCharacterId));
};

const syncLocations = async (): Promise<GeneratedLocation[]> => {
    const files = await glob('30_World_Intel/Locations/*.md', {
        cwd: obsidianRoot,
        nodir: true,
        windowsPathsNoEscape: true
    });

    const items: GeneratedLocation[] = [];
    for (const file of files) {
        const base = path.basename(file);
        if (base.startsWith('_')) continue;

        const absolute = path.join(obsidianRoot, file);
        const raw = await readFile(absolute, 'utf8');
        const parsed = matter(raw);
        const data = parsed.data as Record<string, unknown>;

        const noteId = typeof data.id === 'string' ? data.id : path.basename(file, '.md');
        const runtimeLocationId =
            (typeof data.runtime_location_id === 'string' && data.runtime_location_id.length > 0)
                ? data.runtime_location_id
                : (() => {
                    const match = raw.match(/> \*\*ID\*\*: `([^`]+)`/);
                    return match?.[1] ?? path.basename(file, '.md').toLowerCase();
                })();

        const runtimeTypeMatch = raw.match(/> \*\*Runtime Type\*\*: `([^`]+)`/);
        const runtimeType = runtimeTypeMatch?.[1] ?? null;

        items.push({
            noteId,
            runtimeLocationId,
            title: extractTitle(parsed.content, path.basename(file, '.md')),
            runtimeType,
            source: toPosix(path.join('obsidian/Detectiv', file))
        });
    }

    return items.sort((a, b) => a.runtimeLocationId.localeCompare(b.runtimeLocationId));
};

const syncVoices = async (): Promise<GeneratedVoice[]> => {
    const files = await glob('20_Game_Design/Voices/Voice_*.md', {
        cwd: obsidianRoot,
        nodir: true,
        windowsPathsNoEscape: true
    });

    const items: GeneratedVoice[] = [];
    for (const file of files) {
        const absolute = path.join(obsidianRoot, file);
        const raw = await readFile(absolute, 'utf8');
        const parsed = matter(raw);
        const data = parsed.data as Record<string, unknown>;

        const noteId = typeof data.id === 'string' ? data.id : path.basename(file, '.md');
        const voiceId =
            (typeof data.voice_id === 'string' && data.voice_id.length > 0)
                ? data.voice_id
                : path.basename(file, '.md').replace(/^Voice_/, '').toLowerCase();

        const department = typeof data.department === 'string' ? data.department : null;

        items.push({
            noteId,
            voiceId,
            department,
            source: toPosix(path.join('obsidian/Detectiv', file))
        });
    }

    items.sort((a, b) => a.voiceId.localeCompare(b.voiceId));

    const voiceSet = new Set(items.map((item) => item.voiceId));
    const missing = CANONICAL_VOICE_IDS.filter((id) => !voiceSet.has(id));
    const extra = items.map((item) => item.voiceId).filter((id) => !CANONICAL_VOICE_IDS.includes(id as never));

    if (missing.length > 0) {
        console.warn(`[obsidian-sync] Missing canonical voice notes: ${missing.join(', ')}`);
    }
    if (extra.length > 0) {
        console.warn(`[obsidian-sync] Non-canonical voice notes detected: ${extra.join(', ')}`);
    }

    return items;
};

const main = async (): Promise<void> => {
    await mkdir(generatedDir, { recursive: true });

    const [characters, locations, voices] = await Promise.all([
        syncCharacters(),
        syncLocations(),
        syncVoices()
    ]);

    await Promise.all([
        writeFile(path.join(generatedDir, 'characters.ts'), render('OBSIDIAN_CHARACTERS', characters), 'utf8'),
        writeFile(path.join(generatedDir, 'locations.ts'), render('OBSIDIAN_LOCATIONS', locations), 'utf8'),
        writeFile(path.join(generatedDir, 'voices.ts'), render('OBSIDIAN_VOICES', voices), 'utf8'),
        writeFile(path.join(generatedDir, 'index.ts'), `export * from './characters';\nexport * from './locations';\nexport * from './voices';\n`, 'utf8')
    ]);

    console.log(`[obsidian-sync] Generated data in packages/shared/data/generated`);
    console.log(`[obsidian-sync] Characters: ${characters.length}, Locations: ${locations.length}, Voices: ${voices.length}`);
};

main().catch((error) => {
    console.error('[obsidian-sync] Failed:', error);
    process.exitCode = 1;
});
